var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import React, { useEffect, useState, useRef, cloneElement, useContext, useMemo, useCallback, createContext } from "react";
var classnames = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          } else {
            classes.push(arg.toString());
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames);
var cn = classnames.exports;
class Bus {
  constructor() {
    __publicField(this, "pools", {});
  }
  remove(race, name, func) {
    const targetRace = this.pools[race];
    const events = targetRace && this.pools[race][name];
    if (events) {
      this.pools[race][name] = events.filter((item) => item === func);
    }
  }
  clear(race) {
    this.pools[race] = {};
  }
  on(race, event) {
    if (!this.pools[race]) {
      this.pools[race] = {};
    }
    if (!this.pools[race][event.name]) {
      this.pools[race][event.name] = [];
    }
    this.pools[race][event.name].push(event.callback);
    return this.pools[race][event.name].includes(event.callback);
  }
  emit(race, name, ...params) {
    if (!this.pools[race]) {
      this.pools[race] = {};
    }
    const targetRace = this.pools[race];
    const events = targetRace[name];
    if (events) {
      events.forEach((item) => {
        try {
          item(...params);
        } catch (error) {
          console.error(`${name} monitor event exception\uFF01`, error);
        }
      });
    }
  }
}
var bus = new Bus();
const prefix = "md";
const iconfontUrl = "//at.alicdn.com/t/font_2605852_pqekijay2ij.js";
const highlightUrl = {
  atom: "https://cdn.jsdelivr.net/npm/highlight.js@11.2.0/styles/atom-one-dark.css",
  github: "https://cdn.jsdelivr.net/npm/highlight.js@11.2.0/styles/github.css",
  githubDark: "https://cdn.jsdelivr.net/npm/highlight.js@11.2.0/styles/github-dark.css",
  js: "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js"
};
const prettierUrl = {
  main: "https://cdn.jsdelivr.net/npm/prettier@2.4.0/standalone.js",
  markdown: "https://cdn.jsdelivr.net/npm/prettier@2.4.0/parser-markdown.js"
};
const cropperUrl = {
  css: "https://cdn.jsdelivr.net/npm/cropperjs@1.5.12/dist/cropper.min.css",
  js: "https://cdn.jsdelivr.net/npm/cropperjs@1.5.12/dist/cropper.min.js"
};
const screenfullUrl = "https://cdn.jsdelivr.net/npm/screenfull@5.1.0/dist/screenfull.js";
const allToolbar = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "htmlPreview",
  "catalog",
  "github"
];
const staticTextDefault = {
  "zh-CN": {
    toolbarTips: {
      bold: "\u52A0\u7C97",
      underline: "\u4E0B\u5212\u7EBF",
      italic: "\u659C\u4F53",
      strikeThrough: "\u5220\u9664\u7EBF",
      title: "\u6807\u9898",
      sub: "\u4E0B\u6807",
      sup: "\u4E0A\u6807",
      quote: "\u5F15\u7528",
      unorderedList: "\u65E0\u5E8F\u5217\u8868",
      orderedList: "\u6709\u5E8F\u5217\u8868",
      codeRow: "\u884C\u5185\u4EE3\u7801",
      code: "\u5757\u7EA7\u4EE3\u7801",
      link: "\u94FE\u63A5",
      image: "\u56FE\u7247",
      table: "\u8868\u683C",
      mermaid: "mermaid\u56FE",
      revoke: "\u540E\u9000",
      next: "\u524D\u8FDB",
      save: "\u4FDD\u5B58",
      prettier: "\u7F8E\u5316",
      pageFullscreen: "\u6D4F\u89C8\u5668\u5168\u5C4F",
      fullscreen: "\u5C4F\u5E55\u5168\u5C4F",
      catalog: "\u76EE\u5F55",
      preview: "\u9884\u89C8",
      htmlPreview: "html\u4EE3\u7801\u9884\u89C8",
      github: "\u6E90\u7801\u5730\u5740"
    },
    titleItem: {
      h1: "\u4E00\u7EA7\u6807\u9898",
      h2: "\u4E8C\u7EA7\u6807\u9898",
      h3: "\u4E09\u7EA7\u6807\u9898",
      h4: "\u56DB\u7EA7\u6807\u9898",
      h5: "\u4E94\u7EA7\u6807\u9898",
      h6: "\u516D\u7EA7\u6807\u9898"
    },
    imgTitleItem: {
      link: "\u6DFB\u52A0\u94FE\u63A5",
      upload: "\u4E0A\u4F20\u56FE\u7247",
      clip2upload: "\u88C1\u526A\u4E0A\u4F20"
    },
    linkModalTips: {
      title: "\u6DFB\u52A0",
      descLable: "\u94FE\u63A5\u63CF\u8FF0\uFF1A",
      descLablePlaceHolder: "\u8BF7\u8F93\u5165\u63CF\u8FF0...",
      urlLable: "\u94FE\u63A5\u5730\u5740\uFF1A",
      UrlLablePlaceHolder: "\u8BF7\u8F93\u5165\u94FE\u63A5...",
      buttonOK: "\u786E\u5B9A"
    },
    clipModalTips: {
      title: "\u88C1\u526A\u56FE\u7247\u4E0A\u4F20",
      buttonUpload: "\u4E0A\u4F20"
    },
    copyCode: {
      text: "\u590D\u5236\u4EE3\u7801",
      tips: "\u5DF2\u590D\u5236\uFF01"
    },
    mermaid: {
      flow: "\u6D41\u7A0B\u56FE",
      sequence: "\u65F6\u5E8F\u56FE",
      gantt: "\u7518\u7279\u56FE",
      class: "\u7C7B\u56FE",
      state: "\u72B6\u6001\u56FE",
      pie: "\u997C\u56FE",
      relationship: "\u5173\u7CFB\u56FE",
      journey: "\u65C5\u7A0B\u56FE"
    },
    katex: {
      inline: "\u884C\u5185\u516C\u5F0F",
      block: "\u5757\u7EA7\u516C\u5F0F"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      catalog: "catalog",
      preview: "preview",
      htmlPreview: "html preview",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Img Link",
      upload: "Upload Img",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      title: "Add ",
      descLable: "Desc:",
      descLablePlaceHolder: "Enter a description...",
      urlLable: "Link:",
      UrlLablePlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      tips: "Copied!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    }
  }
};
const mermaidUrl = "https://cdn.jsdelivr.net/npm/mermaid@8.13.5/dist/mermaid.min.js";
const katexJsUrl = "https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js";
const katexCssUrl = "https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css";
const keyMove = (trigger, moveHandler) => {
  const triggerMouseDown = (mdown) => {
    const parent = trigger.parentElement || document.body;
    const width = parent.offsetWidth;
    const height = parent.offsetHeight;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const x = mdown.offsetX;
    const y = mdown.offsetY;
    const mouseMoveHandler = (e) => {
      let tx = e.x + document.body.scrollLeft - document.body.clientLeft - x;
      let ty = e.y + document.body.scrollTop - document.body.clientTop - y;
      tx = tx < 1 ? 1 : tx < clientWidth - width - 1 ? tx : clientWidth - width - 1;
      ty = ty < 1 ? 1 : ty < clientHeight - height - 1 ? ty : clientHeight - height - 1;
      if (moveHandler) {
        moveHandler(tx, ty);
      } else {
        parent.style.left = tx + "px";
        parent.style.top = ty + "px";
      }
    };
    document.addEventListener("mousemove", mouseMoveHandler);
    const mouseUpHandler = () => {
      document.removeEventListener("mousemove", mouseMoveHandler);
      document.removeEventListener("mouseup", mouseUpHandler);
    };
    document.addEventListener("mouseup", mouseUpHandler);
  };
  trigger.addEventListener("mousedown", triggerMouseDown);
  return () => {
    trigger.removeEventListener("mousedown", triggerMouseDown);
  };
};
const appendHandler = (ele) => {
  if (!document.getElementById(ele.id)) {
    document.head.appendChild(ele);
  }
};
const useKeyBoard = (props) => {
  const { editorId } = props;
  const initFunc = (name) => {
    var _a, _b;
    return ((_a = props.toolbars) == null ? void 0 : _a.includes(name)) && !((_b = props.toolbarsExclude) == null ? void 0 : _b.includes(name));
  };
  const keyDownHandler = (event) => {
    if (event.target !== document.querySelector(`#${props.editorId}-textarea`)) {
      return;
    }
    if (event.ctrlKey || event.metaKey) {
      switch (event.code) {
        case "KeyS": {
          if (event.shiftKey) {
            if (initFunc("strikeThrough")) {
              bus.emit(editorId, "replace", "strikeThrough");
            }
          } else {
            if (initFunc("save")) {
              bus.emit(editorId, "onSave", props.modelValue);
              event.preventDefault();
            }
          }
          break;
        }
        case "KeyB": {
          if (initFunc("bold")) {
            bus.emit(editorId, "replace", "bold");
            event.preventDefault();
          }
          break;
        }
        case "KeyU": {
          if (event.shiftKey) {
            if (initFunc("unorderedList")) {
              bus.emit(editorId, "replace", "unorderedList");
              event.preventDefault();
            }
          } else {
            if (initFunc("underline")) {
              bus.emit(editorId, "replace", "underline");
              event.preventDefault();
            }
          }
          break;
        }
        case "KeyI": {
          if (event.shiftKey) {
            if (initFunc("image")) {
              bus.emit(editorId, "openModals", "image");
              event.preventDefault();
            }
          } else {
            if (initFunc("italic")) {
              bus.emit(editorId, "replace", "italic");
              event.preventDefault();
            }
          }
          break;
        }
        case "Digit1": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h1");
            event.preventDefault();
          }
          break;
        }
        case "Digit2": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h2");
            event.preventDefault();
          }
          break;
        }
        case "Digit3": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h3");
            event.preventDefault();
          }
          break;
        }
        case "Digit4": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h4");
            event.preventDefault();
          }
          break;
        }
        case "Digit5": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h5");
            event.preventDefault();
          }
          break;
        }
        case "Digit6": {
          if (initFunc("title")) {
            bus.emit(editorId, "replace", "h6");
            event.preventDefault();
          }
          break;
        }
        case "ArrowUp": {
          if (initFunc("sup")) {
            bus.emit(editorId, "replace", "sup");
            event.preventDefault();
          }
          break;
        }
        case "ArrowDown": {
          if (initFunc("sub")) {
            bus.emit(editorId, "replace", "sub");
            event.preventDefault();
          }
          break;
        }
        case "KeyQ": {
          bus.emit(editorId, "replace", "quote");
          event.preventDefault();
          break;
        }
        case "KeyO": {
          if (initFunc("orderedList")) {
            bus.emit(editorId, "replace", "orderedList");
            event.preventDefault();
          }
          break;
        }
        case "KeyC": {
          if (event.shiftKey) {
            if (initFunc("code")) {
              bus.emit(editorId, "replace", "code");
              event.preventDefault();
            }
          } else if (event.altKey) {
            if (initFunc("codeRow")) {
              bus.emit(editorId, "replace", "codeRow");
              event.preventDefault();
            }
          } else {
            event.preventDefault();
            bus.emit(editorId, "replace", "ctrlC");
            break;
          }
          break;
        }
        case "KeyL": {
          if (initFunc("link")) {
            bus.emit(editorId, "openModals", "link");
            event.preventDefault();
          }
          break;
        }
        case "KeyZ": {
          if (event.shiftKey) {
            if (initFunc("next")) {
              bus.emit(editorId, "ctrlShiftZ");
              event.preventDefault();
            }
          } else {
            if (initFunc("revoke")) {
              bus.emit(editorId, "ctrlZ");
              event.preventDefault();
            }
          }
          break;
        }
        case "KeyF": {
          if (event.shiftKey) {
            if (initFunc("prettier")) {
              bus.emit(editorId, "replace", "prettier");
              event.preventDefault();
            }
          }
          break;
        }
        case "KeyT": {
          if (event.altKey && event.shiftKey) {
            if (initFunc("table")) {
              bus.emit(editorId, "replace", "table");
              event.preventDefault();
            }
          }
          break;
        }
        case "KeyX": {
          bus.emit(editorId, "replace", "ctrlX");
          event.preventDefault();
          break;
        }
        case "KeyD": {
          event.preventDefault();
          bus.emit(editorId, "replace", "ctrlD");
          break;
        }
      }
    } else if (event.code === "Tab") {
      event.preventDefault();
      if (event.shiftKey) {
        bus.emit(editorId, "replace", "shiftTab");
      } else {
        bus.emit(editorId, "replace", "tab");
      }
    }
  };
  useEffect(() => {
    if (!props.previewOnly) {
      window.addEventListener("keydown", keyDownHandler);
    }
    return () => {
      if (!props.previewOnly) {
        window.removeEventListener("keydown", keyDownHandler);
      }
    };
  }, []);
  useEffect(() => {
    if (props.previewOnly) {
      return;
    }
    const callback = () => {
      if (props.onSave) {
        props.onSave(props.modelValue);
      }
    };
    bus.remove(editorId, "onSave", callback);
    bus.on(editorId, {
      name: "onSave",
      callback
    });
  }, [props.modelValue]);
};
const useExpansion = (props) => {
  const {
    iconfontJs,
    prettier,
    prettierCDN,
    prettierMDCDN,
    previewOnly,
    cropperCss,
    cropperJs
  } = props;
  useEffect(() => {
    const iconfontScript = document.createElement("script");
    iconfontScript.src = iconfontJs;
    iconfontScript.id = `${prefix}-icon`;
    const prettierScript = document.createElement("script");
    const prettierMDScript = document.createElement("script");
    prettierScript.src = prettierCDN;
    prettierScript.id = `${prefix}-prettier`;
    prettierMDScript.src = prettierMDCDN;
    prettierMDScript.id = `${prefix}-prettierMD`;
    const cropperLink = document.createElement("link");
    cropperLink.rel = "stylesheet";
    cropperLink.href = cropperCss;
    cropperLink.id = `${prefix}-cropperCss`;
    const cropperScript = document.createElement("script");
    cropperScript.src = cropperJs;
    cropperScript.id = `${prefix}-cropper`;
    if (!previewOnly) {
      appendHandler(iconfontScript);
      if (!props.Cropper) {
        appendHandler(cropperLink);
        appendHandler(cropperScript);
      }
      if (prettier) {
        appendHandler(prettierScript);
        appendHandler(prettierMDScript);
      }
    }
    return () => {
      if (!previewOnly) {
        iconfontScript.remove();
        cropperLink.remove();
        cropperScript.remove();
        if (prettier) {
          prettierScript.remove();
          prettierMDScript.remove();
        }
      }
    };
  }, []);
};
const setPosition = (tarDom, startPos = 0, endPos = startPos) => {
  if (tarDom.setSelectionRange) {
    setTimeout(() => {
      tarDom.setSelectionRange(startPos, endPos);
      tarDom.focus();
    }, 0);
  } else {
    console.log("can not reset position\uFF01");
  }
};
const insert = (dom, tarValue, params) => {
  const { deviationStart = 0, deviationEnd = 0, direct = false, select = false } = params;
  let res = "";
  if (dom.selectionStart || dom.selectionStart === 0) {
    const startPos = dom.selectionStart;
    const endPos = dom.selectionEnd || 0;
    const {
      prefixVal = dom.value.substring(0, startPos),
      subfixVal = dom.value.substring(endPos, dom.value.length)
    } = params;
    res = prefixVal + tarValue + subfixVal;
    setPosition(dom, select ? startPos + deviationStart : startPos + tarValue.length + deviationEnd, startPos + tarValue.length + deviationEnd);
  } else {
    res += tarValue;
  }
  if (direct) {
    dom.value = res;
  }
  return res;
};
const goto = (url, option = {
  newWindow: true,
  nofollow: true
}) => {
  if (!url) {
    console.warn("Invalid link\uFF01");
  }
  const aEle = document.createElement("a");
  aEle.href = url;
  aEle.style.display = "none";
  if (option.newWindow) {
    aEle.target = "_blank";
  }
  if (option.nofollow) {
    aEle.rel = "noopener noreferrer";
  }
  document.body.appendChild(aEle);
  aEle.click();
  aEle.remove();
};
const scrollAuto = (pEle, cEle) => {
  const addEvent = debounce(() => {
    pEle.removeEventListener("scroll", scrollHandler);
    pEle.addEventListener("scroll", scrollHandler);
    cEle.removeEventListener("scroll", scrollHandler);
    cEle.addEventListener("scroll", scrollHandler);
  }, 50);
  const scrollHandler = (e) => {
    const pHeight = pEle.clientHeight;
    const cHeight = cEle.clientHeight;
    const pScrollHeight = pEle.scrollHeight;
    const cScrollHeight = cEle.scrollHeight;
    const scale = (pScrollHeight - pHeight) / (cScrollHeight - cHeight);
    if (e.target === pEle) {
      cEle.removeEventListener("scroll", scrollHandler);
      cEle.scrollTo({
        top: pEle.scrollTop / scale
      });
      addEvent();
    } else {
      pEle.removeEventListener("scroll", scrollHandler);
      pEle.scrollTo({
        top: cEle.scrollTop * scale
      });
      addEvent();
    }
  };
  return [
    addEvent,
    () => {
      pEle.removeEventListener("scroll", scrollHandler);
      cEle.removeEventListener("scroll", scrollHandler);
    }
  ];
};
const base642File = (base64, fileName = "image.png") => {
  const arr = base64.split(",");
  const regResult = arr[0].match(/:(.*?);/);
  if (regResult) {
    const mime = regResult[1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    const file = new File([u8arr], fileName, { type: mime });
    return file;
  }
  return null;
};
const generateCodeRowNumber = (code) => {
  if (!code.trim()) {
    return code;
  }
  const list = code.split("\n");
  const rowNumberList = ['<span rn-wrapper aria-hidden="true">'];
  list.forEach(() => {
    rowNumberList.push("<span></span>");
  });
  rowNumberList.push("</span>");
  return `<span class="code-block">${code}</span>${rowNumberList.join("")}`;
};
const debounce = (fn, ms = 200) => {
  let timer = 0;
  return (...params) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      fn.apply(globalThis, params);
      timer = 0;
    }, ms);
  };
};
var index$1 = "";
var Divider = () => /* @__PURE__ */ React.createElement("div", {
  className: `${prefix}-divider`
});
var style$3 = "";
const HIDDEN_CLASS = `${prefix}-dropdown-hidden`;
const DropDown = (props) => {
  const [ctl, setCtl] = useState({
    overlayClass: HIDDEN_CLASS,
    overlayStyle: {}
  });
  const status = useRef({
    triggerHover: false,
    overlayHover: false
  });
  const triggerRef = useRef(null);
  const overlayRef = useRef(null);
  const triggerHandler = () => {
    if (props.trigger === "hover") {
      status.current.triggerHover = true;
    }
    const triggerEle = triggerRef.current;
    const overlayEle = overlayRef.current;
    const triggerInfo = triggerEle.getBoundingClientRect();
    const triggerTop = triggerEle.offsetTop;
    const triggerLeft = triggerEle.offsetLeft;
    const triggerHeight = triggerInfo.height;
    const triggerWidth = triggerInfo.width;
    setCtl((_ctl) => __spreadProps(__spreadValues({}, _ctl), {
      overlayStyle: {
        top: triggerTop + triggerHeight + "px",
        left: triggerLeft - overlayEle.offsetWidth / 2 + triggerWidth / 2 + "px"
      }
    }));
    props.onChange(true);
  };
  const overlayHandler = () => {
    status.current.overlayHover = true;
  };
  useEffect(() => {
    if (props.visible) {
      setCtl((ctlN) => {
        return __spreadProps(__spreadValues({}, ctlN), {
          overlayClass: ""
        });
      });
    } else {
      setCtl((ctlN) => {
        return __spreadProps(__spreadValues({}, ctlN), {
          overlayClass: HIDDEN_CLASS
        });
      });
    }
  }, [props.visible]);
  const clickHidden = (e) => {
    const triggerEle = triggerRef.current;
    const overlayEle = overlayRef.current;
    if (!triggerEle.contains(e.target) && !overlayEle.contains(e.target)) {
      props.onChange(false);
    }
  };
  const hiddenTimer = useRef(-1);
  const leaveHidden = (e) => {
    if (triggerRef.current === e.target) {
      status.current.triggerHover = false;
    } else {
      status.current.overlayHover = false;
    }
    clearTimeout(hiddenTimer.current);
    hiddenTimer.current = window.setTimeout(() => {
      if (!status.current.overlayHover && !status.current.triggerHover) {
        props.onChange(false);
      }
    }, 10);
  };
  useEffect(() => {
    if (props.trigger === "click") {
      triggerRef.current.addEventListener("click", triggerHandler);
      document.addEventListener("click", clickHidden);
    } else {
      triggerRef.current.addEventListener("mouseenter", triggerHandler);
      triggerRef.current.addEventListener("mouseleave", leaveHidden);
      overlayRef.current.addEventListener("mouseenter", overlayHandler);
      overlayRef.current.addEventListener("mouseleave", leaveHidden);
    }
    return () => {
      if (props.trigger === "click" && triggerRef.current) {
        triggerRef.current.removeEventListener("click", triggerHandler);
        document.removeEventListener("click", clickHidden);
      } else {
        if (triggerRef.current) {
          triggerRef.current.removeEventListener("mouseenter", triggerHandler);
          triggerRef.current.removeEventListener("mouseleave", leaveHidden);
        }
        if (overlayRef.current) {
          overlayRef.current.removeEventListener("mouseenter", overlayHandler);
          overlayRef.current.removeEventListener("mouseleave", leaveHidden);
        }
      }
    };
  }, []);
  const slotDefault = props.children;
  const slotOverlay = props.overlay;
  const trigger = cloneElement(slotDefault, {
    ref: triggerRef
  });
  const overlay = /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-dropdown ${ctl.overlayClass}`,
    style: ctl.overlayStyle,
    ref: overlayRef
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-dropdown-overlay`
  }, slotOverlay instanceof Array ? slotOverlay[0] : slotOverlay));
  return /* @__PURE__ */ React.createElement(React.Fragment, null, trigger, overlay);
};
DropDown.defaultProps = {
  trigger: "hover"
};
var style$2 = "";
const Modal = (props) => {
  const { onClosed = () => {
  } } = props;
  const [modalVisible, setMV] = useState(props.visible);
  const [modalClass, setModalClass] = useState([`${prefix}-modal`]);
  const modalRef = useRef(null);
  const modalHeaderRef = useRef(null);
  const [state, setState] = useState({
    initPos: {
      left: "0px",
      top: "0px"
    },
    historyPos: {
      left: "0px",
      top: "0px"
    }
  });
  const [inited, setInited] = useState(false);
  useEffect(() => {
    let keyMoveClear = () => {
    };
    if (!props.isFullscreen) {
      keyMoveClear = keyMove(modalHeaderRef.current, (left, top) => {
        setState(__spreadProps(__spreadValues({}, state), {
          initPos: {
            left: left + "px",
            top: top + "px"
          }
        }));
      });
    }
    return keyMoveClear;
  }, [inited, props.isFullscreen]);
  useEffect(() => {
    if (modalVisible) {
      const halfWidth = modalRef.current.offsetWidth / 2;
      const halfHeight = modalRef.current.offsetHeight / 2;
      const halfClientWidth = document.documentElement.clientWidth / 2;
      const halfClientHeight = document.documentElement.clientHeight / 2;
      setState(__spreadProps(__spreadValues({}, state), {
        initPos: {
          left: halfClientWidth - halfWidth + "px",
          top: halfClientHeight - halfHeight + "px"
        }
      }));
      !inited && setInited(true);
    }
  }, [modalVisible]);
  useEffect(() => {
    const nVal = props.visible;
    if (nVal) {
      setModalClass(() => [`${prefix}-modal`, "zoom-in"]);
      setMV(nVal);
    } else if (inited) {
      setModalClass(() => [`${prefix}-modal`, "zoom-out"]);
      setTimeout(() => {
        setMV(nVal);
      }, 150);
    }
  }, [props.visible]);
  return /* @__PURE__ */ React.createElement("div", {
    style: { display: modalVisible ? "block" : "none" }
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-mask`,
    onClick: onClosed
  }), /* @__PURE__ */ React.createElement("div", {
    className: cn(modalClass),
    style: __spreadProps(__spreadValues({}, state.initPos), {
      width: props.width,
      height: props.height
    }),
    ref: modalRef
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-header`,
    ref: modalHeaderRef
  }, props.title || ""), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-func`
  }, props.showAdjust && /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-adjust`,
    onClick: (e) => {
      e.stopPropagation();
      if (!props.isFullscreen) {
        setState((_state) => ({
          historyPos: _state.initPos,
          initPos: {
            left: "0",
            top: "0"
          }
        }));
      } else {
        setState((_state) => __spreadProps(__spreadValues({}, _state), {
          initPos: _state.historyPos
        }));
      }
      props.onAdjust(!props.isFullscreen);
    }
  }, /* @__PURE__ */ React.createElement("svg", {
    className: `${prefix}-icon`,
    "aria-hidden": "true"
  }, /* @__PURE__ */ React.createElement("use", {
    xlinkHref: `#icon-${props.isFullscreen ? "suoxiao" : "fangda"}`
  }))), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-close`,
    onClick: (e) => {
      e.stopPropagation();
      props.onClosed && props.onClosed();
    }
  }, /* @__PURE__ */ React.createElement("svg", {
    className: `${prefix}-icon`,
    "aria-hidden": "true"
  }, /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#icon-close"
  })))), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-modal-body`
  }, props.children)));
};
Modal.defaultProps = {
  onAdjust() {
  }
};
const LinkModal = (props) => {
  var _a, _b, _c, _d, _e;
  const { usedLanguageText } = useContext(EditorContext);
  const { editorId } = useContext(EditorContext);
  const title = useMemo(() => {
    var _a2, _b2, _c2, _d2;
    switch (props.type) {
      case "link": {
        return `${(_a2 = usedLanguageText.linkModalTips) == null ? void 0 : _a2.title}${(_b2 = usedLanguageText.toolbarTips) == null ? void 0 : _b2.link}`;
      }
      case "image": {
        return `${(_c2 = usedLanguageText.linkModalTips) == null ? void 0 : _c2.title}${(_d2 = usedLanguageText.toolbarTips) == null ? void 0 : _d2.image}`;
      }
      default: {
        return "";
      }
    }
  }, [props.type]);
  const [linkData, setLinkData] = useState({
    desc: "",
    url: ""
  });
  useEffect(() => {
    if (!props.visible) {
      setTimeout(() => {
        setLinkData({
          desc: "",
          url: ""
        });
      }, 200);
    }
  }, [props.visible]);
  return /* @__PURE__ */ React.createElement(Modal, {
    title,
    visible: props.visible,
    onClosed: props.onCancel
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-form-item`
  }, /* @__PURE__ */ React.createElement("label", {
    className: `${prefix}-lable`,
    htmlFor: `link-desc-${editorId}`
  }, (_a = usedLanguageText.linkModalTips) == null ? void 0 : _a.descLable), /* @__PURE__ */ React.createElement("input", {
    placeholder: (_b = usedLanguageText.linkModalTips) == null ? void 0 : _b.descLablePlaceHolder,
    className: `${prefix}-input`,
    id: `link-desc-${editorId}`,
    type: "text",
    value: linkData.desc,
    onChange: (e) => {
      setLinkData(__spreadProps(__spreadValues({}, linkData), {
        desc: e.target.value
      }));
    }
  })), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-form-item`
  }, /* @__PURE__ */ React.createElement("label", {
    className: `${prefix}-lable`,
    htmlFor: `link-url-${editorId}`
  }, (_c = usedLanguageText.linkModalTips) == null ? void 0 : _c.urlLable), /* @__PURE__ */ React.createElement("input", {
    placeholder: (_d = usedLanguageText.linkModalTips) == null ? void 0 : _d.UrlLablePlaceHolder,
    className: `${prefix}-input`,
    id: `link-url-${editorId}`,
    type: "text",
    value: linkData.url,
    onChange: (e) => {
      setLinkData(__spreadProps(__spreadValues({}, linkData), {
        url: e.target.value
      }));
    }
  })), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-form-item`
  }, /* @__PURE__ */ React.createElement("button", {
    className: `${prefix}-btn ${prefix}-btn-row`,
    type: "button",
    onClick: () => {
      props.onOk(linkData);
      setLinkData(__spreadProps(__spreadValues({}, linkData), {
        desc: "",
        url: ""
      }));
    }
  }, (_e = usedLanguageText.linkModalTips) == null ? void 0 : _e.buttonOK)));
};
var style$1 = "";
let cropper = null;
const ClipModal = (props) => {
  var _a, _b;
  const editorConext = useContext(EditorContext);
  const { editorId, usedLanguageText, Cropper } = editorConext;
  const uploadRef = useRef(null);
  const uploadImgRef = useRef(null);
  const previewTargetRef = useRef(null);
  const [data, setData] = useState({
    cropperInited: false,
    imgSelected: false,
    imgSrc: "",
    isFullscreen: false
  });
  useEffect(() => {
    if (props.visible && !data.cropperInited) {
      window.Cropper = Cropper || window.Cropper;
      uploadRef.current.onchange = () => {
        const fileList = uploadRef.current.files || [];
        if ((fileList == null ? void 0 : fileList.length) > 0) {
          const fileReader = new FileReader();
          fileReader.onload = (e) => {
            setData((_data) => __spreadProps(__spreadValues({}, _data), {
              imgSelected: true,
              imgSrc: e.target.result
            }));
          };
          fileReader.readAsDataURL(fileList[0]);
        }
      };
    }
  }, [props.visible]);
  useEffect(() => {
    if (data.imgSrc) {
      cropper = new window.Cropper(uploadImgRef.current, {
        viewMode: 2,
        preview: `.${prefix}-clip-preview-target`
      });
    }
  }, [data.imgSrc]);
  useEffect(() => {
    var _a2;
    (_a2 = previewTargetRef.current) == null ? void 0 : _a2.setAttribute("style", "");
  }, [data.imgSelected]);
  useEffect(() => {
    var _a2;
    cropper == null ? void 0 : cropper.destroy();
    (_a2 = previewTargetRef.current) == null ? void 0 : _a2.setAttribute("style", "");
    if (uploadImgRef.current) {
      cropper = new window.Cropper(uploadImgRef.current, {
        viewMode: 2,
        preview: `.${prefix}-clip-preview-target`
      });
    }
  }, [data.isFullscreen]);
  const modalSize = useMemo(() => {
    return data.isFullscreen ? {
      width: "100%",
      height: "100%"
    } : {
      width: "668px",
      height: "392px"
    };
  }, [data.isFullscreen]);
  const reset = () => {
    cropper.destroy();
    uploadRef.current.value = "";
    setData((_data) => __spreadProps(__spreadValues({}, _data), {
      imgSrc: "",
      imgSelected: false
    }));
  };
  return /* @__PURE__ */ React.createElement(Modal, __spreadValues({
    title: (_a = usedLanguageText.clipModalTips) == null ? void 0 : _a.title,
    visible: props.visible,
    onClosed: props.onCancel,
    showAdjust: true,
    isFullscreen: data.isFullscreen,
    onAdjust: (val) => {
      setData(__spreadProps(__spreadValues({}, data), {
        isFullscreen: val
      }));
    }
  }, modalSize), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-form-item ${prefix}-clip`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-main`
  }, data.imgSelected ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-cropper`
  }, /* @__PURE__ */ React.createElement("img", {
    src: data.imgSrc,
    ref: uploadImgRef,
    style: { display: "none" }
  }), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-delete`,
    onClick: reset
  }, /* @__PURE__ */ React.createElement("svg", {
    className: `${prefix}-icon`,
    "aria-hidden": "true"
  }, /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#icon-delete"
  })))) : /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-upload`,
    onClick: () => {
      uploadRef.current.click();
    }
  }, /* @__PURE__ */ React.createElement("svg", {
    className: `${prefix}-icon`,
    "aria-hidden": "true"
  }, /* @__PURE__ */ React.createElement("use", {
    xlinkHref: "#icon-upload"
  })))), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-preview`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-clip-preview-target`,
    ref: previewTargetRef
  }))), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-form-item`
  }, /* @__PURE__ */ React.createElement("button", {
    className: `${prefix}-btn`,
    type: "button",
    onClick: () => {
      const cvs = cropper.getCroppedCanvas();
      bus.emit(editorId, "uploadImage", [base642File(cvs.toDataURL("image/png"))], props.onOk);
      reset();
    }
  }, (_b = usedLanguageText.linkModalTips) == null ? void 0 : _b.buttonOK)), /* @__PURE__ */ React.createElement("input", {
    ref: uploadRef,
    accept: "image/*",
    type: "file",
    multiple: false,
    style: { display: "none" }
  }));
};
const Modals = (props) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(LinkModal, {
    type: props.type,
    visible: props.linkVisible,
    onOk: props.onOk,
    onCancel: props.onCancel
  }), /* @__PURE__ */ React.createElement(ClipModal, {
    visible: props.clipVisible,
    onOk: props.onOk,
    onCancel: props.onCancel
  }));
};
const useSreenfull = (props) => {
  let { screenfull } = props;
  const { previewOnly } = useContext(EditorContext);
  const fullScreenHandler = useCallback(() => {
    if (screenfull.isEnabled) {
      if (screenfull.isFullscreen) {
        screenfull.exit();
      } else {
        screenfull.request();
      }
    } else {
      console.error("browser does not support screenfull!");
    }
  }, [screenfull]);
  const screenfullLoad = () => {
    screenfull = window.screenfull;
    if (screenfull && screenfull.isEnabled) {
      screenfull.on("change", () => {
        props.updateSetting("fullscreen");
      });
    }
  };
  useEffect(() => {
    let screenScript;
    if (!previewOnly && !props.screenfull) {
      screenScript = document.createElement("script");
      screenScript.src = props.screenfullJs;
      screenScript.addEventListener("load", screenfullLoad);
      screenScript.id = `${prefix}-screenfull`;
      appendHandler(screenScript);
    }
    if (!previewOnly && screenfull && screenfull.isEnabled) {
      screenfull.on("change", () => {
        props.updateSetting("fullscreen");
      });
    }
    return () => {
      if (!previewOnly && !props.screenfull) {
        screenScript.remove();
      }
    };
  }, []);
  return { fullScreenHandler, screenfullLoad };
};
const TableShape = (props) => {
  const [hoverPosition, setHoverPosition] = useState({
    x: -1,
    y: -1
  });
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-table-shape`,
    onMouseLeave: () => {
      setHoverPosition({
        x: -1,
        y: -1
      });
    }
  }, new Array(props.tableShape[1]).fill("").map((_, rowIndex) => /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-table-shape-row`,
    key: `table-shape-row-${rowIndex}`
  }, new Array(props.tableShape[0]).fill("").map((_2, colIndex) => /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-table-shape-col`,
    key: `table-shape-col-${colIndex}`,
    onMouseEnter: () => {
      setHoverPosition({
        x: rowIndex,
        y: colIndex
      });
    },
    onClick: () => {
      props.onSelected(hoverPosition);
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: cn(`${prefix}-table-shape-col-default`, rowIndex <= hoverPosition.x && colIndex <= hoverPosition.y && `${prefix}-table-shape-col-include`)
  }))))));
};
let splitNum = 0;
const Toolbar = (props) => {
  const { toolbars, toolbarsExclude, setting, updateSetting } = props;
  const { editorId, usedLanguageText } = useContext(EditorContext);
  const ult = usedLanguageText;
  const { fullScreenHandler } = useSreenfull(props);
  const [visible, setVisible] = useState({
    title: false,
    catalog: false,
    image: false,
    table: false,
    mermaid: false,
    katex: false
  });
  const emitHandler = (direct, params) => {
    bus.emit(editorId, "replace", direct, params);
  };
  const [modalData, setModalData] = useState({
    type: "link",
    linkVisible: false,
    clipVisible: false
  });
  const toolbarLeftRef = useRef(null);
  const barRender = (barItem) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T;
    if (allToolbar.includes(barItem)) {
      switch (barItem) {
        case "-": {
          return /* @__PURE__ */ React.createElement(Divider, {
            key: `bar-${splitNum++}`
          });
        }
        case "bold": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_a = ult.toolbarTips) == null ? void 0 : _a.bold,
            onClick: () => {
              emitHandler("bold");
            },
            key: "bar-bold"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-bold"
          })));
        }
        case "underline": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_b = ult.toolbarTips) == null ? void 0 : _b.underline,
            onClick: () => {
              emitHandler("underline");
            },
            key: "bar-underline"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-underline"
          })));
        }
        case "italic": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_c = ult.toolbarTips) == null ? void 0 : _c.italic,
            onClick: () => {
              emitHandler("italic");
            },
            key: "bar-italic"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-italic"
          })));
        }
        case "strikeThrough": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_d = ult.toolbarTips) == null ? void 0 : _d.strikeThrough,
            onClick: () => {
              emitHandler("strikeThrough");
            },
            key: "bar-strikeThrough"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-strike-through"
          })));
        }
        case "title": {
          return /* @__PURE__ */ React.createElement(DropDown, {
            visible: visible.title,
            onChange: (v) => {
              setVisible(__spreadProps(__spreadValues({}, visible), {
                title: v
              }));
            },
            overlay: /* @__PURE__ */ React.createElement("ul", {
              className: `${prefix}-menu`,
              onClick: () => {
                setVisible((_vis) => {
                  return __spreadProps(__spreadValues({}, _vis), {
                    title: false
                  });
                });
              }
            }, /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h1");
              }
            }, (_e = ult.titleItem) == null ? void 0 : _e.h1), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h2");
              }
            }, (_f = ult.titleItem) == null ? void 0 : _f.h2), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h3");
              }
            }, (_g = ult.titleItem) == null ? void 0 : _g.h3), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h4");
              }
            }, (_h = ult.titleItem) == null ? void 0 : _h.h4), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h5");
              }
            }, (_i = ult.titleItem) == null ? void 0 : _i.h5), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("h6");
              }
            }, (_j = ult.titleItem) == null ? void 0 : _j.h6)),
            key: "bar-title"
          }, /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_k = ult.toolbarTips) == null ? void 0 : _k.title
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-title"
          }))));
        }
        case "sub": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_l = ult.toolbarTips) == null ? void 0 : _l.sub,
            onClick: () => {
              emitHandler("sub");
            },
            key: "bar-sub"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-sub"
          })));
        }
        case "sup": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_m = ult.toolbarTips) == null ? void 0 : _m.sup,
            onClick: () => {
              emitHandler("sup");
            },
            key: "bar-sup"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-sup"
          })));
        }
        case "quote": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_n = ult.toolbarTips) == null ? void 0 : _n.quote,
            onClick: () => {
              emitHandler("quote");
            },
            key: "bar-quote"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-quote"
          })));
        }
        case "unorderedList": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_o = ult.toolbarTips) == null ? void 0 : _o.unorderedList,
            onClick: () => {
              emitHandler("unorderedList");
            },
            key: "bar-unorderedList"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-unordered-list"
          })));
        }
        case "orderedList": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_p = ult.toolbarTips) == null ? void 0 : _p.orderedList,
            onClick: () => {
              emitHandler("orderedList");
            },
            key: "bar-orderedList"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-ordered-list"
          })));
        }
        case "codeRow": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_q = ult.toolbarTips) == null ? void 0 : _q.codeRow,
            onClick: () => {
              emitHandler("codeRow");
            },
            key: "bar-codeRow"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-code-row"
          })));
        }
        case "code": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_r = ult.toolbarTips) == null ? void 0 : _r.code,
            onClick: () => {
              emitHandler("code");
            },
            key: "bar-code"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-code"
          })));
        }
        case "link": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_s = ult.toolbarTips) == null ? void 0 : _s.link,
            onClick: () => {
              setModalData(__spreadProps(__spreadValues({}, modalData), {
                type: "link",
                linkVisible: true
              }));
            },
            key: "bar-link"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-link"
          })));
        }
        case "image": {
          return /* @__PURE__ */ React.createElement(DropDown, {
            visible: visible.image,
            onChange: (v) => {
              setVisible((_vis) => {
                return __spreadProps(__spreadValues({}, _vis), {
                  image: v
                });
              });
            },
            overlay: /* @__PURE__ */ React.createElement("ul", {
              className: `${prefix}-menu`,
              onClick: () => {
                setVisible(__spreadProps(__spreadValues({}, visible), {
                  image: false
                }));
              }
            }, /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                modalData.type = "image";
                modalData.linkVisible = true;
              }
            }, (_t = ult.imgTitleItem) == null ? void 0 : _t.link), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                uploadRef.current.click();
              }
            }, (_u = ult.imgTitleItem) == null ? void 0 : _u.upload), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                modalData.clipVisible = true;
              }
            }, (_v = ult.imgTitleItem) == null ? void 0 : _v.clip2upload)),
            key: "bar-image"
          }, /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_w = ult.toolbarTips) == null ? void 0 : _w.image
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-image"
          }))));
        }
        case "table": {
          return /* @__PURE__ */ React.createElement(DropDown, {
            visible: visible.table,
            onChange: (v) => {
              setVisible((_vis) => {
                return __spreadProps(__spreadValues({}, _vis), {
                  table: v
                });
              });
            },
            key: "bar-table",
            overlay: /* @__PURE__ */ React.createElement(TableShape, {
              tableShape: props.tableShape,
              onSelected: (selectedShape) => {
                emitHandler("table", { selectedShape });
              }
            })
          }, /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_x = ult.toolbarTips) == null ? void 0 : _x.table
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-table"
          }))));
        }
        case "revoke": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_y = ult.toolbarTips) == null ? void 0 : _y.revoke,
            onClick: () => {
              bus.emit(editorId, "ctrlZ");
            },
            key: "bar-revoke"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-revoke"
          })));
        }
        case "next": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_z = ult.toolbarTips) == null ? void 0 : _z.next,
            onClick: () => {
              bus.emit(editorId, "ctrlShiftZ");
            },
            key: "bar-next"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-next"
          })));
        }
        case "save": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_A = ult.toolbarTips) == null ? void 0 : _A.save,
            onClick: () => {
              bus.emit(editorId, "onSave");
            },
            key: "bar-save"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-baocun"
          })));
        }
        case "prettier": {
          return props.prettier ? /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_B = ult.toolbarTips) == null ? void 0 : _B.prettier,
            onClick: () => {
              emitHandler("prettier");
            },
            key: "bar-prettier"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-prettier"
          }))) : "";
        }
        case "pageFullscreen": {
          return !setting.fullscreen && /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_C = ult.toolbarTips) == null ? void 0 : _C.pageFullscreen,
            onClick: () => {
              updateSetting("pageFullScreen");
            },
            key: "bar-pageFullscreen"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: `#icon-${setting.pageFullScreen ? "suoxiao" : "fangda"}`
          })));
        }
        case "fullscreen": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_D = ult.toolbarTips) == null ? void 0 : _D.fullscreen,
            onClick: fullScreenHandler,
            key: "bar-fullscreen"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: `#icon-${setting.fullscreen ? "fullScreen-exit" : "fullScreen"}`
          })));
        }
        case "catalog": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_E = ult.toolbarTips) == null ? void 0 : _E.catalog,
            onClick: () => {
              bus.emit(editorId, "catalogShow");
            },
            key: "bar-catalog"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-catalog"
          })));
        }
        case "preview": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_F = ult.toolbarTips) == null ? void 0 : _F.preview,
            onClick: () => {
              updateSetting("preview");
            },
            key: "bar-preview"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-preview"
          })));
        }
        case "htmlPreview": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_G = ult.toolbarTips) == null ? void 0 : _G.htmlPreview,
            onClick: () => {
              updateSetting("htmlPreview");
            },
            key: "bar-htmlPreview"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-coding"
          })));
        }
        case "github": {
          return /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_H = ult.toolbarTips) == null ? void 0 : _H.github,
            onClick: () => goto("https://github.com/imzbf/md-editor-rt"),
            key: "bar-github"
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-github"
          })));
        }
        case "mermaid": {
          return /* @__PURE__ */ React.createElement(DropDown, {
            visible: visible.mermaid,
            onChange: (v) => {
              setVisible((_vis) => {
                return __spreadProps(__spreadValues({}, _vis), {
                  mermaid: v
                });
              });
            },
            overlay: /* @__PURE__ */ React.createElement("ul", {
              className: `${prefix}-menu`,
              onClick: () => {
                setVisible((_vis) => {
                  return __spreadProps(__spreadValues({}, _vis), {
                    mermaid: false
                  });
                });
              }
            }, /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("flow");
              }
            }, (_I = ult.mermaid) == null ? void 0 : _I.flow), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("sequence");
              }
            }, (_J = ult.mermaid) == null ? void 0 : _J.sequence), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("gantt");
              }
            }, (_K = ult.mermaid) == null ? void 0 : _K.gantt), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("class");
              }
            }, (_L = ult.mermaid) == null ? void 0 : _L.class), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("state");
              }
            }, (_M = ult.mermaid) == null ? void 0 : _M.state), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("pie");
              }
            }, (_N = ult.mermaid) == null ? void 0 : _N.pie), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("relationship");
              }
            }, (_O = ult.mermaid) == null ? void 0 : _O.relationship), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("journey");
              }
            }, (_P = ult.mermaid) == null ? void 0 : _P.journey)),
            key: "bar-mermaid"
          }, /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_Q = ult.toolbarTips) == null ? void 0 : _Q.mermaid
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-mermaid"
          }))));
        }
        case "katex": {
          return /* @__PURE__ */ React.createElement(DropDown, {
            visible: visible.katex,
            onChange: (v) => {
              setVisible(__spreadProps(__spreadValues({}, visible), {
                katex: v
              }));
            },
            overlay: /* @__PURE__ */ React.createElement("ul", {
              className: `${prefix}-menu`,
              onClick: () => {
                setVisible(__spreadProps(__spreadValues({}, visible), {
                  katex: false
                }));
              }
            }, /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("katexInline");
              }
            }, (_R = ult.katex) == null ? void 0 : _R.inline), /* @__PURE__ */ React.createElement("li", {
              className: `${prefix}-menu-item`,
              onClick: () => {
                emitHandler("katexBlock");
              }
            }, (_S = ult.katex) == null ? void 0 : _S.block)),
            key: "bar-katex"
          }, /* @__PURE__ */ React.createElement("div", {
            className: `${prefix}-toolbar-item`,
            title: (_T = ult.toolbarTips) == null ? void 0 : _T.katex
          }, /* @__PURE__ */ React.createElement("svg", {
            className: `${prefix}-icon`,
            "aria-hidden": "true"
          }, /* @__PURE__ */ React.createElement("use", {
            xlinkHref: "#icon-formula"
          }))));
        }
      }
    } else if (props.defToolbars && props.defToolbars instanceof Array) {
      const defItem = props.defToolbars[barItem];
      return defItem || "";
    } else {
      return "";
    }
  };
  const splitedbar = useMemo(() => {
    const excluedBars = toolbars.filter((barItem) => !toolbarsExclude.includes(barItem));
    const moduleSplitIndex = excluedBars.indexOf("=");
    const barLeft = moduleSplitIndex === -1 ? excluedBars : excluedBars.slice(0, moduleSplitIndex + 1);
    const barRight = moduleSplitIndex === -1 ? [] : excluedBars.slice(moduleSplitIndex, Number.MAX_SAFE_INTEGER);
    return [barLeft, barRight];
  }, [toolbars, toolbarsExclude]);
  const uploadRef = useRef(null);
  const uploadHandler = () => {
    bus.emit(editorId, "uploadImage", uploadRef.current.files);
    uploadRef.current.value = "";
  };
  useEffect(() => {
    var _a;
    bus.on(editorId, {
      name: "openModals",
      callback(type) {
        setModalData(__spreadProps(__spreadValues({}, modalData), {
          type,
          linkVisible: true
        }));
      }
    });
    (_a = toolbarLeftRef.current) == null ? void 0 : _a.addEventListener("mouseover", () => {
      var _a2;
      if (!((_a2 = window.getSelection()) == null ? void 0 : _a2.toString())) {
        bus.emit(editorId, "selectTextChange", "");
      }
    });
    uploadRef.current.addEventListener("change", uploadHandler);
  }, []);
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar-wrapper`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar`
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar-left`,
    ref: toolbarLeftRef
  }, splitedbar[0].map((barItem) => barRender(barItem))), /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar-right`
  }, splitedbar[1].map((barItem) => barRender(barItem)))), /* @__PURE__ */ React.createElement("input", {
    ref: uploadRef,
    accept: "image/*",
    type: "file",
    multiple: true,
    style: { display: "none" }
  }), /* @__PURE__ */ React.createElement(Modals, {
    linkVisible: modalData.linkVisible,
    clipVisible: modalData.clipVisible,
    type: modalData.type,
    onCancel: () => {
      setModalData(__spreadProps(__spreadValues({}, modalData), {
        linkVisible: false,
        clipVisible: false
      }));
    },
    onOk: (data) => {
      if (data) {
        emitHandler(modalData.type, {
          desc: data.desc,
          url: data.url
        });
      }
      setModalData(__spreadProps(__spreadValues({}, modalData), {
        linkVisible: false,
        clipVisible: false
      }));
    }
  }));
};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  var debug, message, reselectPrevious, range, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range.selectNodeContents(mark);
    selection.addRange(range);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
const splitHelp = (textarea) => {
  const text = textarea.value;
  const prefixStr = text.substring(0, textarea.selectionStart);
  const subfixStr = text.substring(textarea.selectionEnd, text.length);
  const prefixStrIndexOfLineCode = prefixStr.lastIndexOf("\n");
  const prefixStrEndRow = prefixStr.substring(0, prefixStrIndexOfLineCode + 1);
  const subfixStrIndexOfLineCode = subfixStr.indexOf("\n");
  const subfixStrEndRow = subfixStr.substring(subfixStrIndexOfLineCode === -1 ? subfixStr.length : subfixStrIndexOfLineCode, subfixStr.length);
  const prefixSupply = prefixStr.substring(prefixStrIndexOfLineCode + 1, prefixStr.length);
  const subfixSupply = subfixStr.substring(0, subfixStrIndexOfLineCode);
  return {
    prefixStr,
    subfixStr,
    prefixStrEndRow,
    subfixStrEndRow,
    prefixSupply,
    subfixSupply
  };
};
const directive2flag = (direct, selectedText = "", inputArea, params = {}) => {
  var _a, _b;
  let targetValue = "";
  let deviationStart = 0;
  let deviationEnd = 0;
  let select = false;
  let prefixVal;
  let subfixVal;
  if (/^h[1-6]{1}$/.test(direct)) {
    const pix = direct.replace(/^h(\d)/, (_, num) => {
      return new Array(Number(num)).fill("#", 0, num).join("");
    });
    targetValue = `${pix} ${selectedText}`;
    deviationStart = pix.length + 1;
  } else if (direct === "prettier") {
    return window.prettier.format(inputArea.value, {
      parser: "markdown",
      plugins: window.prettierPlugins
    });
  } else {
    switch (direct) {
      case "bold": {
        targetValue = `**${selectedText}**`;
        deviationStart = 2;
        deviationEnd = -2;
        break;
      }
      case "underline": {
        targetValue = `<u>${selectedText}</u>`;
        deviationStart = 3;
        deviationEnd = -4;
        break;
      }
      case "italic": {
        targetValue = `*${selectedText}*`;
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "strikeThrough": {
        targetValue = `~${selectedText}~`;
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "sub": {
        targetValue = `<sub>${selectedText}</sub>`;
        deviationStart = 5;
        deviationEnd = -6;
        break;
      }
      case "sup": {
        targetValue = `<sup>${selectedText}</sup>`;
        deviationStart = 5;
        deviationEnd = -6;
        break;
      }
      case "codeRow": {
        targetValue = "`" + selectedText + "`";
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "quote": {
        targetValue = `> ${selectedText}`;
        deviationStart = 2;
        break;
      }
      case "orderedList": {
        targetValue = `1. ${selectedText}`;
        deviationStart = 3;
        break;
      }
      case "unorderedList": {
        targetValue = `- ${selectedText}`;
        deviationStart = 2;
        break;
      }
      case "code": {
        targetValue = "```language\n" + selectedText + "\n```\n";
        deviationStart = 3;
        deviationEnd = 11 - targetValue.length;
        select = true;
        break;
      }
      case "table": {
        targetValue = "|";
        const { selectedShape = { x: 1, y: 1 } } = params;
        const { x, y } = selectedShape;
        for (let i = 0; i <= y; i++) {
          targetValue += " col |";
        }
        targetValue += "\n|";
        for (let i = 0; i <= y; i++) {
          targetValue += " - |";
        }
        for (let row = 0; row <= x; row++) {
          targetValue += "\n|";
          for (let col = 0; col <= y; col++) {
            targetValue += " content |";
          }
        }
        deviationStart = 2;
        deviationEnd = 5 - targetValue.length;
        select = true;
        break;
      }
      case "link": {
        const { desc, url } = params;
        targetValue = `[${desc}](${url})`;
        break;
      }
      case "image": {
        const { desc, url } = params;
        targetValue = `![${desc}](${url})
`;
        break;
      }
      case "tab": {
        selectedText = ((_a = window.getSelection()) == null ? void 0 : _a.toString()) || "";
        const { tabWidth = 2 } = params;
        const retract = new Array(tabWidth).fill(" ").join("");
        if (selectedText === "") {
          targetValue = retract;
        } else if (/\n/.test(selectedText)) {
          const { prefixStr, subfixStr, prefixSupply, subfixSupply } = splitHelp(inputArea);
          const str2adjust = `${prefixSupply}${selectedText}${subfixSupply}`;
          const str2AdjustRows = str2adjust.split("\n");
          targetValue = str2AdjustRows.map((strItem) => {
            return `${retract}${strItem}`;
          }).join("\n");
          prefixVal = prefixStr.substring(0, prefixStr.length - prefixSupply.length);
          subfixVal = subfixStr.substring(subfixSupply.length, subfixStr.length);
          select = true;
          deviationStart = tabWidth;
          deviationEnd = -prefixSupply.length - subfixSupply.length;
        } else {
          const mdText = inputArea.value;
          const prefixStr = mdText.substring(0, inputArea.selectionStart);
          if (/\n$/.test(prefixStr) || prefixStr === "") {
            targetValue = `${retract}${selectedText}`;
            select = true;
          } else {
            targetValue = retract;
          }
        }
        break;
      }
      case "shiftTab": {
        selectedText = ((_b = window.getSelection()) == null ? void 0 : _b.toString()) || "";
        const { tabWidth = 2 } = params;
        const {
          prefixStr,
          prefixStrEndRow,
          subfixStrEndRow,
          prefixSupply,
          subfixSupply
        } = splitHelp(inputArea);
        const normalReg = new RegExp(`^\\s{${tabWidth}}`);
        const notMultiRow = (selected = false, row = false) => {
          const str2adjust = `${prefixSupply}${selectedText}${subfixSupply}`;
          if (normalReg.test(str2adjust)) {
            const startPos = prefixStr.length - (row ? 0 : tabWidth);
            const endPos = selected ? startPos + selectedText.length - tabWidth : startPos;
            setPosition(inputArea, startPos, endPos);
            return `${prefixStrEndRow}${str2adjust.replace(normalReg, "")}${subfixStrEndRow}`;
          } else if (/^\s/.test(str2adjust)) {
            const deletedTabStr = str2adjust.replace(/^\s/, "");
            const deletedLength = str2adjust.length - deletedTabStr.length;
            const startPos = inputArea.selectionStart - (row ? 0 : deletedLength);
            const endPos = selected ? startPos + selectedText.length - deletedLength : startPos;
            setPosition(inputArea, startPos, endPos);
            return `${prefixStrEndRow}${deletedTabStr}${subfixStrEndRow}`;
          } else {
            targetValue = selectedText;
          }
        };
        if (selectedText === "") {
          const newContent = notMultiRow();
          if (newContent) {
            return newContent;
          }
        } else if (/\n/.test(selectedText)) {
          const str2adjust = `${prefixSupply}${selectedText}${subfixSupply}`;
          const str2AdjustRows = str2adjust.split("\n");
          let [firstRowDelNum, totalRowDelNum] = [0, 0];
          const str2AdjustRowsMod = str2AdjustRows.map((strItem, index2) => {
            if (normalReg.test(strItem)) {
              if (index2 === 0) {
                firstRowDelNum = tabWidth;
              }
              totalRowDelNum += tabWidth;
              return strItem.replace(normalReg, "");
            } else if (/^\s/.test(strItem)) {
              const deletedTabStr = strItem.replace(/^\s/, "");
              totalRowDelNum += strItem.length - deletedTabStr.length;
              return deletedTabStr;
            }
            return strItem;
          }).join("\n");
          setPosition(inputArea, inputArea.selectionStart - firstRowDelNum, inputArea.selectionEnd - totalRowDelNum);
          return `${prefixStrEndRow}${str2AdjustRowsMod}${subfixStrEndRow}`;
        } else {
          const newContent = notMultiRow(true, true);
          if (newContent) {
            return newContent;
          }
        }
        break;
      }
      case "ctrlC": {
        const { prefixSupply, subfixSupply } = splitHelp(inputArea);
        if (selectedText === "") {
          copyToClipboard(`${prefixSupply}${subfixSupply}`);
        } else {
          copyToClipboard(selectedText);
        }
        return inputArea.value;
      }
      case "ctrlX": {
        const {
          prefixStrEndRow,
          subfixStrEndRow,
          prefixStr,
          subfixStr,
          prefixSupply,
          subfixSupply
        } = splitHelp(inputArea);
        if (selectedText === "") {
          copyToClipboard(`${prefixSupply}${subfixSupply}`);
          setPosition(inputArea, prefixStrEndRow.length);
          return `${prefixStrEndRow}${subfixStrEndRow.replace(/^\n/, "")}`;
        } else {
          copyToClipboard(selectedText);
          setPosition(inputArea, prefixStr.length);
          return `${prefixStr}${subfixStr}`;
        }
      }
      case "ctrlD": {
        const { prefixStrEndRow, subfixStrEndRow } = splitHelp(inputArea);
        setPosition(inputArea, prefixStrEndRow.length);
        return `${prefixStrEndRow}${subfixStrEndRow.replace(/^\n/, "")}`;
      }
      case "flow": {
        targetValue = `\`\`\`mermaid
flowchart TD 
  Start --> Stop
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "sequence": {
        targetValue = `\`\`\`mermaid
sequenceDiagram
  A->>B: hello!
  B-->>A: hi!
  A-)B: bye!
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "gantt": {
        targetValue = `\`\`\`mermaid
gantt
title A Gantt Diagram
dateFormat  YYYY-MM-DD
section Section
A task  :a1, 2014-01-01, 30d
Another task  :after a1, 20d
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "class": {
        targetValue = `\`\`\`mermaid
classDiagram
  class Animal
  Vehicle <|-- Car
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "state": {
        targetValue = `\`\`\`mermaid
stateDiagram-v2
  s1 --> s2
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "pie": {
        targetValue = `\`\`\`mermaid
pie title Pets adopted by volunteers
  "Dogs" : 386
  "Cats" : 85
  "Rats" : 15
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "relationship": {
        targetValue = `\`\`\`mermaid
erDiagram
  CAR ||--o{ NAMED-DRIVER : allows
  PERSON ||--o{ NAMED-DRIVER : is
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "journey": {
        targetValue = `\`\`\`mermaid
journey
  title My working day
  section Go to work
    Make tea: 5: Me
    Go upstairs: 3: Me
    Do work: 1: Me, Cat
  section Go home
    Go downstairs: 5: Me
    Sit down: 5: Me
\`\`\`
`;
        deviationStart = 2;
        break;
      }
      case "katexInline": {
        targetValue = "$$";
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "katexBlock": {
        targetValue = "$$\n\n$$\n";
        deviationStart = 1;
        deviationEnd = -4;
        break;
      }
    }
  }
  return insert(inputArea, targetValue, {
    deviationStart,
    deviationEnd,
    select,
    prefixVal,
    subfixVal
  });
};
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = /[&<>"']/g;
const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = { exec: function noopTest2() {
} };
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.substr(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text, [])
    };
    lexer.state.inLink = false;
    return token;
  } else {
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text)
    };
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class Tokenizer {
  constructor(options) {
    this.options = options || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, "");
      return {
        type: "blockquote",
        raw: cap[0],
        tokens: this.lexer.blockTokens(text, []),
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0];
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            line = rawLine;
            if (this.options.pedantic) {
              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (nextBulletRegex.test(line)) {
              break;
            }
            if (line.search(/[^ ]/) >= indent || !line.trim()) {
              itemContents += "\n" + line.slice(indent);
            } else if (!blankLine) {
              itemContents += "\n" + line;
            } else {
              break;
            }
            if (!blankLine && !line.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        const spacers = list.items[i].tokens.filter((t) => t.type === "space");
        const hasMultipleLineBreaks = spacers.every((t) => {
          const chars = t.raw.split("");
          let lineBreaks = 0;
          for (const char of chars) {
            if (char === "\n") {
              lineBreaks += 1;
            }
            if (lineBreaks > 1) {
              return true;
            }
          }
          return false;
        });
        if (!list.loose && spacers.length && hasMultipleLineBreaks) {
          list.loose = true;
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        token.type = "paragraph";
        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.tokens = [];
        this.lexer.inline(token.text, token.tokens);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3])
        cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      return {
        type: "def",
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = [];
          this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = [];
            this.lexer.inlineTokens(row[k].text, row[k].tokens);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      const token = {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const token = {
        type: "paragraph",
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      const token = {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: []
      };
      this.lexer.inline(token.text, token.tokens);
      return token;
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = src.slice(1, lLength + match.index + rLength);
          return {
            type: "em",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
        const text = src.slice(2, lLength + match.index + rLength - 1);
        return {
          type: "strong",
          raw: src.slice(0, lLength + match.index + rLength + 1),
          text,
          tokens: this.lexer.inlineTokens(text, [])
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2], [])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + text;
        } else {
          href = text;
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = merge({}, block);
block.gfm = merge({}, block.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
});
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = merge({}, block.normal, {
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = merge({}, inline);
inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
});
inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  static get rules() {
    return {
      block,
      inline
    };
  }
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/^ +$/gm, "");
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens) {
    this.inlineQueue.push({ src, tokens });
  }
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
}
class Renderer {
  constructor(options) {
    this.options = options || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  }
  html(html) {
    return html;
  }
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
    }
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text) {
    return "<li>" + text + "</li>\n";
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  paragraph(text) {
    return "<p>" + text + "</p>\n";
  }
  table(header, body) {
    if (body)
      body = "<tbody>" + body + "</tbody>";
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
    return tag + content + "</" + type + ">\n";
  }
  strong(text) {
    return "<strong>" + text + "</strong>";
  }
  em(text) {
    return "<em>" + text + "</em>";
  }
  codespan(text) {
    return "<code>" + text + "</code>";
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  del(text) {
    return "<del>" + text + "</del>";
  }
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape(href) + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
}
class TextRenderer {
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  slug(value, options = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}
class Parser {
  constructor(options) {
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }
  parse(tokens, top = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
          continue;
        }
        case "code": {
          out += this.renderer.code(token.text, token.lang, token.escaped);
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), { header: true, align: token.align[j] });
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: token.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
}
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
marked.options = marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const opts = merge({}, ...args);
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  let hasExtensions;
  args.forEach((pack) => {
    if (pack.extensions) {
      hasExtensions = true;
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        pack.walkTokens.call(this, token);
        if (walkTokens) {
          walkTokens.call(this, token);
        }
      };
    }
    if (hasExtensions) {
      opts.extensions = extensions;
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback.call(marked, token);
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          marked.walkTokens(cell.tokens, callback);
        }
        for (const row of token.rows) {
          for (const cell of row) {
            marked.walkTokens(cell.tokens, callback);
          }
        }
        break;
      }
      case "list": {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            marked.walkTokens(token[childTokens], callback);
          });
        } else if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};
marked.parseInline = function(src, opt) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
};
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
Parser.parse;
Lexer.lex;
var kaTexExtensions = {
  block(prefix2, katex) {
    return {
      name: "KaTexBlockExtension",
      level: "block",
      start: (text) => {
        var _a;
        return (_a = text.match(/\$\$\n/)) == null ? void 0 : _a.index;
      },
      tokenizer(text) {
        const reg = /^\$\$\n([^$]*)\$\$\n?/;
        const match = reg.exec(text);
        if (match) {
          const token = {
            type: "KaTexBlockExtension",
            raw: match[0],
            text: match[1].trim(),
            tokens: []
          };
          return token;
        }
      },
      renderer(token) {
        const _katex = katex || typeof window !== "undefined" && window.katex;
        if (_katex) {
          const html = _katex.renderToString(token.text, {
            throwOnError: false
          });
          return `<span class="${prefix2}-katex-block" data-processed>${html}</span>`;
        } else {
          return `<span class="${prefix2}-katex-block">${token.text}</span>`;
        }
      }
    };
  },
  inline(prefix2, katex) {
    return {
      name: "KaTexInlineExtension",
      level: "inline",
      start: (text) => {
        var _a;
        return (_a = text.match(/\$[^$]/)) == null ? void 0 : _a.index;
      },
      tokenizer(text) {
        const reg = /^\$([^$]*)\$/;
        const match = reg.exec(text);
        if (match) {
          const token = {
            type: "KaTexInlineExtension",
            raw: match[0],
            text: match[1].trim(),
            tokens: []
          };
          return token;
        }
      },
      renderer(token) {
        const _katex = katex || typeof window !== "undefined" && window.katex;
        if (_katex) {
          const html = _katex.renderToString(token.text, {
            throwOnError: false
          });
          return `<span class="${prefix2}-katex-inline" data-processed>${html}</span>`;
        } else {
          return `<span class="${prefix2}-katex-inline">${token.text}</span>`;
        }
      }
    };
  }
};
let saveHistoryId = -1;
const useHistory = (props, textAreaRef) => {
  const { onChange } = props;
  const { historyLength, editorId } = useContext(EditorContext);
  const history = useRef({
    list: [],
    userUpdated: true,
    curr: 0
  });
  useEffect(() => {
    var _a, _b;
    clearTimeout(saveHistoryId);
    const startPos = ((_a = textAreaRef.current) == null ? void 0 : _a.selectionStart) || 0;
    const endPos = ((_b = textAreaRef.current) == null ? void 0 : _b.selectionEnd) || 0;
    saveHistoryId = window.setTimeout(() => {
      if (history.current.userUpdated) {
        if (history.current.curr < history.current.list.length - 1) {
          history.current.list = history.current.list.slice(0, history.current.curr + 1);
        }
        if (history.current.list.length > historyLength) {
          history.current.list.shift();
        }
        const lastStep = history.current.list.pop() || {
          startPos: 0,
          endPos: 0,
          content: props.value
        };
        lastStep.startPos = startPos;
        lastStep.endPos = endPos;
        Array.prototype.push.call(history.current.list, lastStep, {
          content: props.value,
          startPos,
          endPos
        });
        history.current.curr = history.current.list.length - 1;
      } else {
        history.current.userUpdated = true;
      }
    }, 500);
  }, [props.value]);
  useEffect(() => {
    bus.on(editorId, {
      name: "ctrlZ",
      callback() {
        history.current.userUpdated = false;
        history.current.curr = history.current.curr - 1 < 0 ? 0 : history.current.curr - 1;
        const currHistory = history.current.list[history.current.curr];
        onChange(currHistory.content);
        setPosition(textAreaRef.current, currHistory.startPos, currHistory.endPos);
      }
    });
    bus.on(editorId, {
      name: "ctrlShiftZ",
      callback() {
        history.current.userUpdated = false;
        history.current.curr = history.current.curr + 1 === history.current.list.length ? history.current.curr : history.current.curr + 1;
        const currHistory = history.current.list[history.current.curr];
        onChange(currHistory.content);
        setPosition(textAreaRef.current, currHistory.startPos, currHistory.endPos);
      }
    });
  }, []);
};
const useAutoGenrator = (props, textAreaRef) => {
  const selectedText = useRef("");
  const { previewOnly, tabWidth, editorId } = useContext(EditorContext);
  useEffect(() => {
    var _a, _b;
    if (!previewOnly) {
      (_a = textAreaRef.current) == null ? void 0 : _a.addEventListener("select", () => {
        var _a2;
        selectedText.current = ((_a2 = window.getSelection()) == null ? void 0 : _a2.toString()) || "";
      });
      (_b = textAreaRef.current) == null ? void 0 : _b.addEventListener("keypress", (event) => {
        var _a2, _b2, _c;
        if (event.key === "Enter") {
          const endPoint = (_a2 = textAreaRef.current) == null ? void 0 : _a2.selectionStart;
          const prefixStr = (_b2 = textAreaRef.current) == null ? void 0 : _b2.value.substring(0, endPoint);
          const subStr = (_c = textAreaRef.current) == null ? void 0 : _c.value.substring(endPoint);
          const lastIndexBR = prefixStr == null ? void 0 : prefixStr.lastIndexOf("\n");
          const enterPressRow = prefixStr == null ? void 0 : prefixStr.substring(lastIndexBR + 1, endPoint);
          if (/^\d+\.\s|^-\s/.test(enterPressRow)) {
            event.cancelBubble = true;
            event.preventDefault();
            event.stopPropagation();
            if (/^\d+\.\s+$|^-\s+$/.test(enterPressRow)) {
              const resetPrefixStr = prefixStr == null ? void 0 : prefixStr.replace(new RegExp(enterPressRow + "$"), "");
              props.onChange(resetPrefixStr + subStr);
              setPosition(textAreaRef.current, resetPrefixStr == null ? void 0 : resetPrefixStr.length);
            } else if (/^-\s+.+/.test(enterPressRow)) {
              props.onChange(insert(textAreaRef.current, "\n- ", {}));
            } else {
              const lastOrderMatch = enterPressRow == null ? void 0 : enterPressRow.match(/\d+(?=\.)/);
              const nextOrder = lastOrderMatch && Number(lastOrderMatch[0]) + 1 || 1;
              props.onChange(insert(textAreaRef.current, `
${nextOrder}. `, {}));
            }
          }
        }
      });
      bus.on(editorId, {
        name: "selectTextChange",
        callback(val) {
          selectedText.current = val;
        }
      });
    }
  }, []);
  const replaceCallBack = (direct, params = {}) => {
    props.onChange(directive2flag(direct, selectedText.current, textAreaRef.current, __spreadProps(__spreadValues({}, params), {
      tabWidth
    })));
  };
  useEffect(() => {
    if (!previewOnly) {
      bus.remove(editorId, "replace", replaceCallBack);
      bus.on(editorId, {
        name: "replace",
        callback: replaceCallBack
      });
    }
  }, [textAreaRef]);
  return {
    selectedText
  };
};
const useMarked = (props, heading) => {
  const [inited, setInited] = useState(false);
  if (!inited) {
    setInited(true);
    const renderer = new marked.Renderer();
    renderer.heading = heading;
    renderer.defaultCode = renderer.code;
    renderer.code = (code, language, isEscaped) => {
      var _a;
      if (!props.noMermaid && language === "mermaid") {
        const idRand = `${prefix}-mermaid-${Date.now().toString(36)}`;
        try {
          let svgCode = "";
          if (props.mermaid) {
            svgCode = props.mermaid.mermaidAPI.render(idRand, code);
          } else if (typeof window !== "undefined" && window.mermaid) {
            svgCode = window.mermaid.mermaidAPI.render(idRand, code);
          } else {
            svgCode = `<div class="mermaid">${code}</div>`;
          }
          return `<div class="${prefix}-mermaid">${svgCode}</div>`;
        } catch (error) {
          if (typeof document !== "undefined") {
            const errorDom = document.querySelector(`#${idRand}`);
            if (errorDom) {
              const errorSvg = errorDom.outerHTML;
              (_a = errorDom.parentElement) == null ? void 0 : _a.remove();
              return errorSvg;
            }
          }
          return "";
        }
      }
      return renderer.defaultCode(code, language, isEscaped);
    };
    renderer.image = (href, _, desc) => {
      return `<figure><img src="${href}" alt="${desc}"><figcaption>${desc}</figcaption></figure>`;
    };
    marked.setOptions({
      renderer,
      breaks: true
    });
    if (props.extensions instanceof Array && props.extensions.length > 0) {
      marked.use({
        extensions: props.extensions
      });
    }
  }
  return marked;
};
const useMermaid = (props) => {
  const { theme } = useContext(EditorContext);
  const [reRender, setReRender] = useState(false);
  const [mermaidInited, setMermaidInited] = useState(!!props.mermaid);
  useEffect(() => {
    if (!props.noMermaid) {
      if (props.mermaid) {
        props.mermaid.initialize({
          theme: theme === "dark" ? "dark" : "default"
        });
      } else if (window.mermaid) {
        window.mermaid.initialize({
          theme: theme === "dark" ? "dark" : "default"
        });
      }
      setReRender((_reRender) => !_reRender);
    }
  }, [theme]);
  useEffect(() => {
    let mermaidScript;
    if (!props.noMermaid && !props.mermaid) {
      mermaidScript = document.createElement("script");
      mermaidScript.src = props.mermaidJs;
      mermaidScript.onload = () => {
        window.mermaid.initialize({
          theme: theme === "dark" ? "dark" : "default",
          logLevel: "Fatal"
        });
        setMermaidInited(true);
      };
      mermaidScript.id = `${prefix}-mermaid`;
      appendHandler(mermaidScript);
    }
    return () => {
      if (!props.noMermaid && !props.mermaid) {
        mermaidScript.remove();
      }
    };
  }, []);
  return { reRender, mermaidInited };
};
const useKatex = (props, marked2) => {
  const [katexInited, setKatexInited] = useState(false);
  if (!props.noKatex) {
    marked2.use({
      extensions: [
        kaTexExtensions.inline(prefix, props.katex),
        kaTexExtensions.block(prefix, props.katex)
      ]
    });
  }
  useEffect(() => {
    let katexScript;
    let katexLink;
    if (!props.noKatex && !props.katex) {
      katexScript = document.createElement("script");
      katexScript.src = props.katexJs;
      katexScript.onload = () => {
        setKatexInited(true);
      };
      katexScript.id = `${prefix}-katex`;
      katexLink = document.createElement("link");
      katexLink.rel = "stylesheet";
      katexLink.href = props.katexCss;
      katexLink.id = `${prefix}-katexCss`;
      appendHandler(katexScript);
      appendHandler(katexLink);
    }
    return () => {
      katexScript && katexScript.remove();
      katexLink && katexLink.remove();
    };
  }, []);
  return katexInited;
};
const useAutoScroll = (props, html, textAreaRef, previewRef, htmlRef) => {
  const { previewOnly } = useContext(EditorContext);
  const [scrollCb, setScrollCb] = useState({
    clear() {
    },
    init() {
    }
  });
  useEffect(() => {
    const [init, clear] = scrollAuto(textAreaRef.current, previewRef.current || htmlRef.current);
    setScrollCb({
      init,
      clear
    });
  }, []);
  useEffect(() => {
    if (props.setting.preview && !previewOnly) {
      setTimeout(() => {
        scrollCb.clear();
        scrollCb.init();
      }, 0);
    }
  }, [html]);
  useEffect(() => {
    if (props.setting.preview && !previewOnly) {
      scrollCb.clear();
      const [init, clear] = scrollAuto(textAreaRef.current, previewRef.current);
      setScrollCb({
        init,
        clear
      });
      init();
    }
  }, [props.setting.preview, setScrollCb]);
  useEffect(() => {
    if (props.setting.htmlPreview && !previewOnly) {
      scrollCb.clear();
      const [init, clear] = scrollAuto(textAreaRef.current, htmlRef.current);
      setScrollCb({
        init,
        clear
      });
      init();
    }
  }, [props.setting.htmlPreview, setScrollCb]);
};
const usePasteUpload = (textAreaRef) => {
  const { editorId, previewOnly } = useContext(EditorContext);
  const pasteHandler = (e) => {
    if (e.clipboardData && e.clipboardData.files.length > 0) {
      const file = e.clipboardData.files[0];
      if (/image\/.*/.test(file.type)) {
        bus.emit(editorId, "uploadImage", [file]);
        e.preventDefault();
      }
    }
  };
  useEffect(() => {
    var _a;
    if (!previewOnly) {
      (_a = textAreaRef.current) == null ? void 0 : _a.addEventListener("paste", pasteHandler);
    }
    return () => {
      var _a2;
      if (!previewOnly) {
        (_a2 = textAreaRef.current) == null ? void 0 : _a2.removeEventListener("paste", pasteHandler);
      }
    };
  }, []);
};
const Content = (props) => {
  const {
    hljs = null,
    highlightSet,
    onChange = () => {
    },
    onHtmlChanged = () => {
    },
    onGetCatalog = () => {
    }
  } = props;
  const { editorId, previewOnly, usedLanguageText, previewTheme, showCodeRowNumber } = useContext(EditorContext);
  const [highlightInited, setHighlightInited] = useState(!!hljs);
  const textAreaRef = useRef(null);
  const selectedText = useRef("");
  const previewRef = useRef(null);
  const htmlRef = useRef(null);
  const heads = useRef([]);
  const heading = (...headProps) => {
    const [, level, raw] = headProps;
    heads.current.push({ text: raw, level });
    return props.markedHeading(...headProps);
  };
  const marked2 = useMarked(props, heading);
  const katexInited = useKatex(props, marked2);
  const { reRender, mermaidInited } = useMermaid(props);
  const initCopyEntry = () => {
    document.querySelectorAll(`#${editorId} .${prefix}-preview pre`).forEach((pre) => {
      var _a;
      const copyButton = document.createElement("span");
      copyButton.setAttribute("class", "copy-button");
      copyButton.innerText = ((_a = usedLanguageText.copyCode) == null ? void 0 : _a.text) || "\u590D\u5236\u4EE3\u7801";
      copyButton.addEventListener("click", () => {
        var _a2;
        copyToClipboard(pre.querySelector("code").innerText);
        copyButton.innerText = ((_a2 = usedLanguageText.copyCode) == null ? void 0 : _a2.tips) || "\u5DF2\u590D\u5236\uFF01";
        setTimeout(() => {
          var _a3;
          copyButton.innerText = ((_a3 = usedLanguageText.copyCode) == null ? void 0 : _a3.text) || "\u590D\u5236\u4EE3\u7801";
        }, 1500);
      });
      pre.appendChild(copyButton);
    });
  };
  const highlightLoad = () => {
    marked2.setOptions({
      highlight(code) {
        const codeHtml = window.hljs.highlightAuto(code).value;
        return showCodeRowNumber ? generateCodeRowNumber(codeHtml) : `<span class="code-block">${codeHtml}</span>`;
      }
    });
    setHighlightInited(true);
  };
  useEffect(() => {
    let highlightLink;
    let highlightScript;
    if (props.hljs) {
      marked2.setOptions({
        highlight: (code) => {
          var _a;
          const codeHtml = (_a = props.hljs) == null ? void 0 : _a.highlightAuto(code).value;
          return showCodeRowNumber ? generateCodeRowNumber(codeHtml) : `<span class="code-block">${codeHtml}</span>`;
        }
      });
    } else {
      highlightLink = document.createElement("link");
      highlightLink.rel = "stylesheet";
      highlightLink.href = highlightSet.css;
      highlightLink.id = `${prefix}-hlCss`;
      highlightScript = document.createElement("script");
      highlightScript.src = highlightSet.js;
      highlightScript.onload = highlightLoad;
      highlightScript.id = `${prefix}-hljs`;
      appendHandler(highlightLink);
      appendHandler(highlightScript);
    }
    return () => {
      if (!props.hljs) {
        highlightLink.remove();
        highlightScript.remove();
      }
    };
  }, []);
  const html = useMemo(() => {
    heads.current = [];
    const _html = marked2(props.value);
    return props.sanitize(_html);
  }, [props.value, highlightInited, mermaidInited, reRender, katexInited]);
  useEffect(() => {
    onHtmlChanged(html);
    onGetCatalog(heads.current);
    bus.emit(editorId, "catalogChanged", heads.current);
    initCopyEntry();
  }, [html]);
  useAutoScroll(props, html, textAreaRef, previewRef, htmlRef);
  useHistory(props, textAreaRef);
  useAutoGenrator(props, textAreaRef);
  usePasteUpload(textAreaRef);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-content`
  }, !previewOnly && /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-input-wrapper`
  }, /* @__PURE__ */ React.createElement("textarea", {
    id: `${editorId}-textarea`,
    ref: textAreaRef,
    value: props.value,
    onInput: (e) => {
      selectedText.current = "";
      onChange(e.target.value);
    },
    className: props.setting.preview || props.setting.htmlPreview ? "" : "textarea-only",
    placeholder: props.placeholder
  })), props.setting.preview && /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-preview-wrapper`,
    ref: previewRef,
    key: "content-preview-wrapper"
  }, /* @__PURE__ */ React.createElement("div", {
    id: `${prefix}-preview`,
    className: cn(`${prefix}-preview`, `${previewTheme}-theme`, showCodeRowNumber && `${prefix}-scrn`),
    dangerouslySetInnerHTML: { __html: html }
  })), props.setting.htmlPreview && /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-preview-wrapper`,
    ref: htmlRef,
    key: "html-preview-wrapper"
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-html`
  }, html))));
};
var style = "";
const CatalogLink = (props) => {
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-catalog-link`,
    onClick: (e) => {
      var _a;
      e.stopPropagation();
      const id = props.markedHeadingId(props.tocItem.text, props.tocItem.level);
      const targetHeadEle = document.getElementById(id);
      const previewEle = document.getElementById(`${prefix}-preview`);
      if (targetHeadEle) {
        const scrollLength = targetHeadEle.offsetTop;
        (_a = previewEle == null ? void 0 : previewEle.parentElement) == null ? void 0 : _a.scrollTo({
          top: scrollLength,
          behavior: "smooth"
        });
      }
    }
  }, /* @__PURE__ */ React.createElement("span", null, props.tocItem.text), props.tocItem.children && props.tocItem.children.map((item) => /* @__PURE__ */ React.createElement(CatalogLink, {
    markedHeadingId: props.markedHeadingId,
    key: item.text,
    tocItem: item
  })));
};
const Catalog = (props) => {
  const { editorId } = useContext(EditorContext);
  const [list, setList] = useState([]);
  const catalogs = useMemo(() => {
    const tocItems = [];
    list.forEach(({ text, level }) => {
      const item = { level, text };
      if (tocItems.length === 0) {
        tocItems.push(item);
      } else {
        let lastItem = tocItems[tocItems.length - 1];
        if (item.level > lastItem.level) {
          for (let i = lastItem.level + 1; i <= 6; i++) {
            const { children } = lastItem;
            if (!children) {
              lastItem.children = [item];
              break;
            }
            lastItem = children[children.length - 1];
            if (item.level <= lastItem.level) {
              children.push(item);
              break;
            }
          }
        } else {
          tocItems.push(item);
        }
      }
    });
    return tocItems;
  }, [list]);
  const [show, setShow] = useState(false);
  useEffect(() => {
    bus.on(editorId, {
      name: "catalogChanged",
      callback: (_list) => {
        setList(_list);
      }
    });
    bus.on(editorId, {
      name: "catalogShow",
      callback: () => {
        setShow((_val) => {
          return !_val;
        });
      }
    });
  }, []);
  return show ? /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-catalog`
  }, catalogs.map((item) => {
    return /* @__PURE__ */ React.createElement(CatalogLink, {
      markedHeadingId: props.markedHeadingId,
      tocItem: item,
      key: item.text
    });
  })) : null;
};
const DropdownToolbar = (props) => {
  return /* @__PURE__ */ React.createElement(DropDown, {
    visible: props.visible,
    onChange: props.onChange,
    overlay: props.overlay
  }, /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar-item`,
    title: props.title || ""
  }, props.trigger));
};
const NormalToolbar = (props) => {
  return /* @__PURE__ */ React.createElement("div", {
    className: `${prefix}-toolbar-item`,
    title: props.title,
    onClick: props.onClick
  }, props.trigger);
};
var index = "";
var all = "";
const EditorContext = createContext({
  editorId: "",
  tabWidth: 2,
  historyLength: 10,
  previewOnly: false,
  showCodeRowNumber: false,
  usedLanguageText: staticTextDefault["zh-CN"],
  Cropper: null,
  theme: "light",
  previewTheme: "default"
});
let bodyOverflowHistory = "";
const markedHeadingId = (text) => text;
const Editor = (props) => {
  const {
    theme,
    editorClass,
    toolbars,
    toolbarsExclude,
    preview,
    htmlPreview,
    previewOnly,
    pageFullScreen,
    editorId,
    tabWidth,
    screenfull,
    screenfullJs
  } = props;
  useKeyBoard(props);
  useExpansion(props);
  const [setting, setSetting] = useState({
    pageFullScreen,
    fullscreen: false,
    preview,
    htmlPreview: preview ? false : htmlPreview
  });
  const updateSetting = (k) => {
    setSetting((settingN) => {
      const nextSetting = __spreadProps(__spreadValues({}, settingN), {
        [k]: !settingN[k]
      });
      if (k === "preview" && nextSetting.preview) {
        nextSetting.htmlPreview = false;
      } else if (k === "htmlPreview" && nextSetting.htmlPreview) {
        nextSetting.preview = false;
      }
      return nextSetting;
    });
  };
  const uploadImageCallBack = (files, cb) => {
    const insertHanlder = (urls) => {
      urls.forEach((url) => {
        setTimeout(() => {
          bus.emit(editorId, "replace", "image", {
            desc: "",
            url
          });
        }, 0);
      });
      cb && cb();
    };
    if (props.onUploadImg) {
      props.onUploadImg(files, insertHanlder);
    }
  };
  useEffect(() => {
    if (!previewOnly) {
      bus.remove(editorId, "uploadImage", uploadImageCallBack);
      bus.on(editorId, {
        name: "uploadImage",
        callback: uploadImageCallBack
      });
      bodyOverflowHistory = document.body.style.overflow;
    }
    return () => {
      bus.clear(editorId);
    };
  }, []);
  useEffect(() => {
    if (setting.pageFullScreen || setting.fullscreen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = bodyOverflowHistory;
    }
  }, [setting.pageFullScreen, setting.fullscreen]);
  const highlightSet = useMemo(() => {
    let url = highlightUrl.atom;
    if (props.highlightCss) {
      url = props.highlightCss;
    } else {
      switch (props.previewTheme) {
        case "github": {
          if (props.theme === "dark") {
            url = highlightUrl.githubDark;
          } else {
            url = highlightUrl.github;
          }
          break;
        }
      }
    }
    return {
      js: props.highlightJs,
      css: url
    };
  }, [props.highlightCss, props.previewTheme, props.theme]);
  const usedLanguageText = useMemo(() => {
    const allText = __spreadValues(__spreadValues({}, staticTextDefault), props.languageUserDefined);
    if (allText[props.language]) {
      return allText[props.language];
    } else {
      return staticTextDefault["zh-CN"];
    }
  }, [props.languageUserDefined, props.language]);
  const catalogShow = useMemo(() => {
    return !toolbarsExclude.includes("catalog") && toolbars.includes("catalog");
  }, [toolbars, toolbarsExclude]);
  return /* @__PURE__ */ React.createElement(EditorContext.Provider, {
    value: {
      editorId,
      tabWidth,
      theme: props.theme,
      historyLength: props.historyLength,
      previewOnly,
      showCodeRowNumber: props.showCodeRowNumber,
      usedLanguageText,
      Cropper: props.Cropper,
      previewTheme: props.previewTheme
    }
  }, /* @__PURE__ */ React.createElement("div", {
    id: editorId,
    className: cn([
      prefix,
      editorClass,
      theme === "dark" && `${prefix}-dark`,
      setting.fullscreen || setting.pageFullScreen ? `${prefix}-fullscreen` : "",
      previewOnly && `${prefix}-previewOnly`
    ]),
    style: props.style
  }, !previewOnly && /* @__PURE__ */ React.createElement(Toolbar, {
    prettier: props.prettier,
    screenfull,
    screenfullJs,
    toolbars,
    toolbarsExclude,
    setting,
    updateSetting,
    tableShape: props.tableShape,
    defToolbars: props.defToolbars
  }), /* @__PURE__ */ React.createElement(Content, {
    hljs: props.hljs,
    highlightSet,
    mermaid: props.mermaid,
    mermaidJs: props.mermaidJs,
    noMermaid: props.noMermaid,
    value: props.modelValue,
    onChange: props.onChange,
    setting,
    onHtmlChanged: props.onHtmlChanged,
    onGetCatalog: props.onGetCatalog,
    markedHeading: props.markedHeading,
    sanitize: props.sanitize,
    placeholder: props.placeholder,
    katex: props.katex,
    katexJs: props.katexJs,
    katexCss: props.katexCss,
    noKatex: props.noKatex,
    extensions: props.extensions
  }), catalogShow && /* @__PURE__ */ React.createElement(Catalog, {
    markedHeadingId: props.markedHeadingId
  })));
};
Editor.defaultProps = {
  modelValue: "",
  theme: "light",
  editorClass: "",
  highlightJs: highlightUrl.js,
  highlightCss: "",
  historyLength: 10,
  onChange() {
  },
  pageFullScreen: false,
  preview: true,
  htmlPreview: false,
  previewOnly: false,
  language: "zh-CN",
  languageUserDefined: {},
  toolbars: allToolbar,
  toolbarsExclude: [],
  prettier: true,
  prettierCDN: prettierUrl.main,
  prettierMDCDN: prettierUrl.markdown,
  cropperCss: cropperUrl.css,
  cropperJs: cropperUrl.js,
  iconfontJs: iconfontUrl,
  editorId: `md-editor-rt`,
  tabWidth: 2,
  showCodeRowNumber: false,
  screenfullJs: screenfullUrl,
  previewTheme: "default",
  markedHeading: (text, level, raw) => {
    const id = markedHeadingId(raw);
    if (text !== raw) {
      return `<h${level} id="${id}">${text}</h${level}>`;
    } else {
      return `<h${level} id="${id}"><a href="#${id}">${raw}</a></h${level}>`;
    }
  },
  markedHeadingId,
  style: {},
  tableShape: [6, 4],
  mermaidJs: mermaidUrl,
  sanitize: (html) => html,
  placeholder: "",
  katexJs: katexJsUrl,
  katexCss: katexCssUrl
};
Editor.DropdownToolbar = DropdownToolbar;
Editor.NormalToolbar = NormalToolbar;
export { EditorContext, Editor as default };
